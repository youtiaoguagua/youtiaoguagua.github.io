<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>jdk及cglib动态代理原理</title>
    <url>/2021/12/29/cglib/</url>
    <content><![CDATA[<h1 id="jdk及cglib动态代理原理"><a href="#jdk及cglib动态代理原理" class="headerlink" title="jdk及cglib动态代理原理"></a>jdk及cglib动态代理原理</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="https://cdn.jsdelivr.net/gh/youtiaoguagua/blog-img/blog/cglib.png"
                        alt="依赖关系图"
                 ></p>
<ul>
<li><p>日志框架logback，引入logback-classic即可引入日志实现层和api</p>
</li>
<li><p>测试框架junit,引入junit-jupiter即可，这是一个聚合pom</p>
</li>
<li><p>引入cglig库</p>
</li>
</ul>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>java动态代理有两种实现方式：</p>
<ul>
<li><p>JDK动态代理：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</p>
</li>
<li><p>CGLIB动态代理：利用asm，修改字节码生成子类来处理。</p>
</li>
</ul>
<h3 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h3><h4 id="代理方法执行分析"><a href="#代理方法执行分析" class="headerlink" title="代理方法执行分析"></a>代理方法执行分析</h4><blockquote>
<p>具体实现如下，使用jdk自带的<code>Proxy</code>实现<code>InvocationHandler</code>接口即可对代理对象进行增强</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HelloWorldImpl</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloWorldImpl</span>();</span><br><span class="line"><span class="type">HelloWorld</span> <span class="variable">helloWorld</span> <span class="operator">=</span> (HelloWorld) Proxy.newProxyInstance(HelloWorld.class.getClassLoader(), 		HelloWorldImpl.class.getInterfaces(), (obj, method, args) -&gt; &#123;</span><br><span class="line">    log.info(<span class="string">&quot;调用方法开始：&#123;&#125;&quot;</span>, method.getName());</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(o, args);</span><br><span class="line">    log.info(<span class="string">&quot;调用结果:&#123;&#125;&quot;</span>, result);</span><br><span class="line">    log.info(<span class="string">&quot;调用方法结束：&#123;&#125;&quot;</span>, method.getName());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line">log.info(helloWorld.sayHello(<span class="string">&quot;hello world&quot;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过设置以下代码可以查看jdk动态生成的class文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  设置java动态代理调试模式,在junit中设置此方法是无效的！</span></span><br><span class="line">System.getProperties().put(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>下面为生成的代理类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├───com</span><br><span class="line">│   └───sun</span><br><span class="line">│       └───proxy</span><br><span class="line">│               $Proxy0.class   # 生成的代理类</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">sayHello</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (String)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var3;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面为生成的的class文件反编译后的一个方法，很容易的看出，代理方法只是很简单的调用了<code>InvocationHandler</code>类中的<code>invoke</code>方法，在<code>invoke</code>方法中又会调用代理方法的<code>invoke</code>方法，这个<code>invoke</code>方法是反射方法，因此被代理的方法就被调用了，因此jdk动态代理是通过实现被代理类的接口，然后通过反射执行被代理方法实现的。</p>
<h4 id="生成代理类分析"><a href="#生成代理类分析" class="headerlink" title="生成代理类分析"></a>生成代理类分析</h4><blockquote>
<p>下面咱们来看一下这个动态代理类是怎么生成的</p>
</blockquote>
<p>下面为<code>Proxy.newProxyInstance</code>的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很容易看出<code>getProxyClass0</code>就是生成代理类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较有意思的一点是当被代理类的接口数量大于65535时就会报错，我们都知道一个类可以实现多个接口，但是这个接口数量也是有限制的，挺有意思的😂！</p>
<p>代理类是被放在一个弱引用map里的，接下来就是从map中取出接口的代理类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">    proxyClassCache = <span class="keyword">new</span> <span class="title class_">WeakCache</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">KeyFactory</span>(), <span class="keyword">new</span> <span class="title class_">ProxyClassFactory</span>());</span><br></pre></td></tr></table></figure>

<p>上面就是这个map构造方式，提供了key和value的构造工厂。</p>
<p>KeyFactory:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//很简单的通过实现类的数量生成了一个Key对象    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">KeyFactory</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">BiFunction</span>&lt;ClassLoader, Class&lt;?&gt;[], Object&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">apply</span><span class="params">(ClassLoader classLoader, Class&lt;?&gt;[] interfaces)</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (interfaces.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Key1</span>(interfaces[<span class="number">0</span>]); <span class="comment">// the most frequent</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Key2</span>(interfaces[<span class="number">0</span>], interfaces[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> key0;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyX</span>(interfaces);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ProxyClassFactory：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ProxyClassFactory</span></span><br><span class="line">       <span class="keyword">implements</span> <span class="title class_">BiFunction</span>&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 代理类的前缀</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">proxyClassNamePrefix</span> <span class="operator">=</span> <span class="string">&quot;$Proxy&quot;</span>;</span><br><span class="line">       <span class="comment">// next number to use for generation of unique proxy class names</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">nextUniqueNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">           Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>&lt;&gt;(interfaces.length);</span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">               <span class="comment">//验证类加载器是否将此接口的名称解析为相同的 Class 对象,简单点说就是这个接口是否可以被提供的类加载器加载。</span></span><br><span class="line">               Class&lt;?&gt; interfaceClass = <span class="literal">null</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   interfaceClass = Class.forName(intf.getName(), <span class="literal">false</span>, loader);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                       intf + <span class="string">&quot; is not visible from class loader&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 确认是否是个接口</span></span><br><span class="line">               <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                       interfaceClass.getName() + <span class="string">&quot; is not an interface&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//验证接口是否是重复的</span></span><br><span class="line">               <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                       <span class="string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">String</span> <span class="variable">proxyPkg</span> <span class="operator">=</span> <span class="literal">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">accessFlags</span> <span class="operator">=</span> Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">           <span class="comment">// 看注释挺绕的，应该就是想设置一个包名</span></span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> intf.getModifiers();</span><br><span class="line">               <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                   accessFlags = Modifier.FINAL;</span><br><span class="line">                   <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> intf.getName();</span><br><span class="line">                   <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                   <span class="type">String</span> <span class="variable">pkg</span> <span class="operator">=</span> ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                   <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">                       proxyPkg = pkg;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                           <span class="string">&quot;non-public interfaces from different packages&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">               proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 设置代理类类名称</span></span><br><span class="line">           <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> nextUniqueNumber.getAndIncrement();</span><br><span class="line">           <span class="type">String</span> <span class="variable">proxyName</span> <span class="operator">=</span> proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//生成代理类</span></span><br><span class="line">           <span class="type">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">               proxyName, interfaces, accessFlags);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                                   proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过上面我们可以很容易的了解代理类生成的过程了，<code>ProxyGenerator.generateProxyClass</code>应该是最重要的了，但是没必要深究了，无非就是生成方法，生成构造器等。另外上面提到在junit中无法通过设置变量生成代理类class文件，我们可以直接调用<code>ProxyGenerator.generateProxyClass</code>手动生成。</p>
<h3 id="Cglib动态代理分析"><a href="#Cglib动态代理分析" class="headerlink" title="Cglib动态代理分析"></a>Cglib动态代理分析</h3><h4 id="代理方法执行分析-1"><a href="#代理方法执行分析-1" class="headerlink" title="代理方法执行分析"></a>代理方法执行分析</h4><blockquote>
<p>同jdk动态代理一样，首先要打开cglib的debug模式才能看见代理类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  设置Cglib动态代理调试模式</span></span><br><span class="line">System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">&quot;target&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>写一个最简单的使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">enhancer.setSuperclass(HelloWorldImpl.class);</span><br><span class="line">enhancer.setCallback((MethodInterceptor) (obj, method, args, methodProxy) -&gt; &#123;</span><br><span class="line">    log.info(<span class="string">&quot;调用方法开始：&#123;&#125;&quot;</span>, method.getName());</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invokeSuper(obj, args);</span><br><span class="line">    log.info(<span class="string">&quot;调用结果:&#123;&#125;&quot;</span>, result);</span><br><span class="line">    log.info(<span class="string">&quot;调用方法结束：&#123;&#125;&quot;</span>, method.getName());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">HelloWorld</span> <span class="variable">helloWorld</span> <span class="operator">=</span> (HelloWorld) enhancer.create();</span><br><span class="line">log.info(helloWorld.sayHello(<span class="string">&quot;cglib&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>运行之后在target中看一下生成的代理类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├───com</span><br><span class="line">│   └───example</span><br><span class="line">│       └───cglib</span><br><span class="line">│           └───proxy</span><br><span class="line">│               └───impl</span><br><span class="line">│                       HelloWorldImpl$$EnhancerByCGLIB$$722f73d4$$FastClassByCGLIB$$5d1e80b1.class</span><br><span class="line">│                       HelloWorldImpl$$EnhancerByCGLIB$$722f73d4.class</span><br><span class="line">│                       HelloWorldImpl$$FastClassByCGLIB$$d5c59250.class</span><br></pre></td></tr></table></figure>

<p>可以看见生成了三个类，下面来看一下这三个类都有什么吧，ヾ(≧▽≦*)o</p>
<ol>
<li><p><code>HelloWorldImpl$$EnhancerByCGLIB$$722f73d4</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldImpl$$EnhancerByCGLIB$$722f73d4</span> <span class="keyword">extends</span> <span class="title class_">HelloWorldImpl</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">//省略大部分代码</span></span><br><span class="line">    <span class="keyword">final</span> String CGLIB$sayHello$<span class="number">1</span>(String var1) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">sayHello</span><span class="params">(String var1)</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//省略大部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类类似于jdk动态代理生成的那个代理类，之后我们来看他是怎么执行的。</p>
</li>
<li><p><code>HelloWorldImpl$$EnhancerByCGLIB$$722f73d4$$FastClassByCGLIB$$5d1e80b1.class</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldImpl$$EnhancerByCGLIB$$722f73d4$$FastClassByCGLIB$$5d1e80b1</span> <span class="keyword">extends</span> <span class="title class_">FastClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HelloWorldImpl$$EnhancerByCGLIB$$722f73d4$$FastClassByCGLIB$$5d1e80b1(Class var1) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Signature var1)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(String var1, Class[] var2)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Class[] var1)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="type">int</span> var1, Object var2, Object[] var3)</span> <span class="keyword">throws</span> InvocationTargetException &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">newInstance</span><span class="params">(<span class="type">int</span> var1, Object[] var2)</span> <span class="keyword">throws</span> InvocationTargetException &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxIndex</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个类里最重要的就是<code>getIndex</code>方法和<code>invoke</code>方法。</p>
</li>
<li><p><code>HelloWorldImpl$$FastClassByCGLIB$$d5c59250.class</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldImpl$$FastClassByCGLIB$$d5c59250</span> <span class="keyword">extends</span> <span class="title class_">FastClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HelloWorldImpl$$FastClassByCGLIB$$d5c59250(Class var1) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Signature var1)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(String var1, Class[] var2)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Class[] var1)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="type">int</span> var1, Object var2, Object[] var3)</span> <span class="keyword">throws</span> InvocationTargetException &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">newInstance</span><span class="params">(<span class="type">int</span> var1, Object[] var2)</span> <span class="keyword">throws</span> InvocationTargetException &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxIndex</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和上一个类相似，但是有本质区别。</p>
</li>
</ol>
<blockquote>
<p>下面将对上面的三个类进行分析</p>
</blockquote>
<p>先不分析<code>enhancer.create</code>方法，首先上面的例子会调用<code>HelloWorld.sayHello</code>方法，然后调用代理类的<code>sayHello</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">sayHello</span><span class="params">(String var1)</span> &#123;</span><br><span class="line">    <span class="type">MethodInterceptor</span> <span class="variable">var10000</span> <span class="operator">=</span> <span class="built_in">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="keyword">if</span> (var10000 == <span class="literal">null</span>) &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="built_in">this</span>);</span><br><span class="line">        var10000 = <span class="built_in">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var10000 != <span class="literal">null</span> ? (String)var10000.intercept(<span class="built_in">this</span>, CGLIB$sayHello$<span class="number">1</span>$Method, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;, CGLIB$sayHello$<span class="number">1</span>$Proxy) : <span class="built_in">super</span>.sayHello(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见<code>sayHello</code>方法会去掉用上面设置的回调方法，然后就进入了我们自己写的<code>callBack</code>方法，<code>callback</code>方法的一个继承接口是<code>MethodInterceptor</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title class_">Callback</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见这个<code>intercept</code>方法有四个参数：</p>
<ul>
<li><code>obj</code>是代理类</li>
<li><code>method</code>是被代理类的方法</li>
<li><code>args</code>是方法传入的参数</li>
<li><code>proxy</code>是代理类的方法</li>
</ul>
<p>之后肯定是执行方法了，首先可以想到的是直接调用<code>method.invoke</code>方法，这个其实就是jdk动态代理执行方法的方式，使用反射执行，这样就没cglib的优势了。值得注意的是<code>invoke</code>的第一个参数不要直接传入参的<code>obj</code>,这样会造成死循环，至于为什么会这样后面会解释。</p>
<p>不使用<code>method.invoke</code>执行方法，那么只能使用<code>proxy</code>去执行方法了，问题又来了，这个<code>proxy</code>有两个方法<code>invoke</code>和<code>invokeSuper</code>方法，那么这两个方法有什么区别呢？</p>
<blockquote>
<p>首先来看<code>invokeSuper</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invokeSuper</span><span class="params">(Object obj, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="type">FastClassInfo</span> <span class="variable">fci</span> <span class="operator">=</span> fastClassInfo;</span><br><span class="line">        <span class="keyword">return</span> fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fastClassInfo == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (initLock)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fastClassInfo == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">CreateInfo</span> <span class="variable">ci</span> <span class="operator">=</span> createInfo;</span><br><span class="line"></span><br><span class="line">                <span class="type">FastClassInfo</span> <span class="variable">fci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastClassInfo</span>();</span><br><span class="line">                fci.f1 = helper(ci, ci.c1);</span><br><span class="line">                fci.f2 = helper(ci, ci.c2);</span><br><span class="line">                fci.i1 = fci.f1.getIndex(sig1);</span><br><span class="line">                fci.i2 = fci.f2.getIndex(sig2);</span><br><span class="line">                fastClassInfo = fci;</span><br><span class="line">                createInfo = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> MethodProxy <span class="title function_">create</span><span class="params">(Class c1, Class c2, String desc, String name1, String name2)</span> &#123;</span><br><span class="line">    <span class="type">MethodProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodProxy</span>();</span><br><span class="line">    proxy.sig1 = <span class="keyword">new</span> <span class="title class_">Signature</span>(name1, desc);</span><br><span class="line">    proxy.sig2 = <span class="keyword">new</span> <span class="title class_">Signature</span>(name2, desc);</span><br><span class="line">    proxy.createInfo = <span class="keyword">new</span> <span class="title class_">CreateInfo</span>(c1, c2);</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HelloWorldImpl$$EnhancerByCGLIB$$722f73d4静态代码块</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK1() &#123;</span><br><span class="line">    CGLIB$THREAD_CALLBACKS = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">    CGLIB$emptyArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>];</span><br><span class="line">    CGLIB$sayHello$<span class="number">4</span>$Method = var10000[<span class="number">4</span>];</span><br><span class="line">    CGLIB$sayHello$<span class="number">4</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span>, <span class="string">&quot;sayHello&quot;</span>, <span class="string">&quot;CGLIB$sayHello$4&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见<code>invokeSuper</code>首先调用了<code>init</code>方法，<code>init</code>方法需要一个<code>createInfo</code>这个<code>createInfo</code>方法是由<code>create</code>方法创建的，那么这个<code>create</code>是由什么调用的呢，通过debug可以看见是由我们的<code>HelloWorldImpl</code>代理类在静态代码块中调用的，可以看见这个代码块传递了方法参数，和代理类中的两个方法，查看这两个方法可以看出<code>sayHello</code>会调用<code>callback</code>而<code>CGLIB$sayHello$4</code>会调用被代理类的<code>sayHello</code>方法。</p>
<p>得到<code>ci</code>类之后之后会调用<code>helper</code>方法，这个方法主要就是生成两个<code>fastClass</code>类，通过<code>fastClass.getIndex</code>可以很快的得到执行的方法。而<code>f2</code>其实就是被代理类的执行方法，因此可以看出<code>fci.f2.invoke</code>其实执行的就是<code>CGLIB$sayHello$4</code>方法。从头到尾没有使用反射执行方法，简单的通过<code>super.sayHelloWorld</code>就完成了方法的执行。这也是cglib比jdk动态代理快的奥秘。</p>
<blockquote>
<p>下面我们look look<code>proxy.invoke</code>方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object obj, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="type">FastClassInfo</span> <span class="variable">fci</span> <span class="operator">=</span> fastClassInfo;</span><br><span class="line">        <span class="keyword">return</span> fci.f1.invoke(fci.i1, obj, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fastClassInfo.i1 &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Protected method: &quot;</span> + sig1);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见和<code>invokeSuper</code>几乎一样，只是最后调用的是<code>fci.f1.invoke</code>方法，在<code>invokeSuper</code>中我们传入的obj参数就是<code>MethodInterceptor#intercept</code>所传给我们的<code>obj</code>，如果在<code>invoke</code>也传入这个<code>obj</code>的话，那么将会进入死循环，为什么会出现死循环呢，从上面的<code>init</code>方法中我们可以得出<code>f1</code>其实执行的是<code>sayHello</code>方法，而代理对象的<code>sayHello</code>方法会接着执行<code>MethodInterceptor#intercept</code>方法，然后<code>MethodInterceptor#intercept</code>会接着执行<code>invoke</code>方法，从而陷入死循环，解决这个问题很简单，就是自己<code>new</code>一个<code>HelloWorldImpl</code>对象传入，这样执行的就是你传入的这个对象的<code>sayHello</code>方法而不是代理对象的。上面提到的如果你执行<code>method.invoke</code>传入参数的<code>obj</code>会陷入死循环是一个道理，因为执行的是代理类的<code>sayHello</code>，而代理类的<code>sayHello</code>会接着执行<code>callback</code>。</p>
<h4 id="生成代理类分析-1"><a href="#生成代理类分析-1" class="headerlink" title="生成代理类分析"></a>生成代理类分析</h4><p>下面我们来see see <code>enhancer.create</code>干了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">    classOnly = <span class="literal">false</span>;</span><br><span class="line">    argumentTypes = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> createHelper();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">createHelper</span><span class="params">()</span> &#123;</span><br><span class="line">    preValidate();</span><br><span class="line">    <span class="comment">// 这个key其实就是个上下文，后面可以根据这个key创建代理类</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> KEY_FACTORY.newInstance((superclass != <span class="literal">null</span>) ? superclass.getName() : <span class="literal">null</span>,</span><br><span class="line">            ReflectUtils.getNames(interfaces),</span><br><span class="line">            filter == ALL_ZERO ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">WeakCacheKey</span>&lt;CallbackFilter&gt;(filter),</span><br><span class="line">            callbackTypes,</span><br><span class="line">            useFactory,</span><br><span class="line">            interceptDuringConstruction,</span><br><span class="line">            serialVersionUID);</span><br><span class="line">    <span class="built_in">this</span>.currentKey = key;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">super</span>.create(key);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">create</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.key = key;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> data.get(<span class="built_in">this</span>, getUseCache());</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstInstance((Class) obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextInstance(obj);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>data.get</code>将会生成<code>class</code>文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">KK</span> <span class="variable">cacheKey</span> <span class="operator">=</span> keyMapper.apply(key);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> map.get(cacheKey);</span><br><span class="line">    <span class="comment">// 从map里找，如果有的话就不会构建class文件了</span></span><br><span class="line">    <span class="keyword">if</span> (v != <span class="literal">null</span> &amp;&amp; !(v <span class="keyword">instanceof</span> FutureTask)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (V) v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> createEntry(key, cacheKey, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> V <span class="title function_">createEntry</span><span class="params">(<span class="keyword">final</span> K key, KK cacheKey, Object v)</span> &#123;</span><br><span class="line">    FutureTask&lt;V&gt; task;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">creator</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果有别的线程已经执行了，那么就不创建新线程了</span></span><br><span class="line">        task = (FutureTask&lt;V&gt;) v;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;V&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;V&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> loader.apply(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">prevTask</span> <span class="operator">=</span> map.putIfAbsent(cacheKey, task);</span><br><span class="line">        <span class="comment">// 查看map中是否已经存在任务了</span></span><br><span class="line">        <span class="keyword">if</span> (prevTask == <span class="literal">null</span>) &#123;   </span><br><span class="line">            creator = <span class="literal">true</span>;</span><br><span class="line">            task.run();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevTask <span class="keyword">instanceof</span> FutureTask) &#123;</span><br><span class="line">            task = (FutureTask&lt;V&gt;) prevTask;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (V) prevTask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    V result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = task.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Interrupted while loading cache item&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ((RuntimeException) cause);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unable to load cache item&quot;</span>, cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (creator) &#123;</span><br><span class="line">        map.put(cacheKey, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>loader.apply</code>将会生成代理,调用<code>net.sf.cglib.proxy.Enhancer#generateClass</code>构造<code>org.objectweb.asm.ClassVisitor</code>，之后生成代理类，里头的逻辑比较多，就不一一分析了，主要是使用了asm库构造新类。</p>
<h2 id="Cglib的使用"><a href="#Cglib的使用" class="headerlink" title="Cglib的使用"></a>Cglib的使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;不同的回调实现&quot;)</span></span><br><span class="line"><span class="meta">@Nested</span></span><br><span class="line"><span class="meta">@Tag(&quot;cglib&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DifferentCallback</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;为每个方法设置回调&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMultiCallBack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(HelloWorldImpl.class);</span><br><span class="line">        enhancer.setCallbackFilter(<span class="keyword">new</span> <span class="title class_">CglibFilter</span>());</span><br><span class="line">        enhancer.setCallbacks(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>[]&#123;<span class="keyword">new</span> <span class="title class_">AuthInterceptor</span>(), <span class="keyword">new</span> <span class="title class_">NormalInterceptor</span>()&#125;);</span><br><span class="line">        <span class="type">HelloWorld</span> <span class="variable">helloWorld</span> <span class="operator">=</span> (HelloWorld) enhancer.create();</span><br><span class="line">        log.info(<span class="string">&quot;最终返回结果：&#123;&#125;&quot;</span>, helloWorld.sayHello(<span class="string">&quot;cglib&quot;</span>));</span><br><span class="line">        log.info(<span class="string">&quot;最终返回结果：&#123;&#125;&quot;</span>, helloWorld.sayGoodBye(<span class="string">&quot;cglib&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;FixedValue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFixedValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(HelloWorldImpl.class);</span><br><span class="line">        enhancer.setCallback((FixedValue) () -&gt; <span class="string">&quot;fixedValue&quot;</span>);</span><br><span class="line">        <span class="type">HelloWorld</span> <span class="variable">helloWorld</span> <span class="operator">=</span> (HelloWorld) enhancer.create();</span><br><span class="line">        log.info(<span class="string">&quot;最终返回结果：&#123;&#125;&quot;</span>, helloWorld.sayHello(<span class="string">&quot;cglib&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;NoOp&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testNoOp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(HelloWorldImpl.class);</span><br><span class="line">        enhancer.setCallback(NoOp.INSTANCE);</span><br><span class="line">        <span class="type">HelloWorld</span> <span class="variable">helloWorld</span> <span class="operator">=</span> (HelloWorld) enhancer.create();</span><br><span class="line">        log.info(<span class="string">&quot;最终返回结果：&#123;&#125;&quot;</span>, helloWorld.sayHello(<span class="string">&quot;cglib&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;LazyLoader&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLazyLoader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HelloWorldImpl</span> <span class="variable">helloWorld</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloWorldImpl</span>();</span><br><span class="line">        <span class="type">HelloWorldImpl</span> <span class="variable">helloWorldLazy</span> <span class="operator">=</span> helloWorld.lazyLoad();</span><br><span class="line">        log.info(<span class="string">&quot;开始调用getField方法....&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;lazyLoad:&#123;&#125;&quot;</span>, helloWorldLazy.getField());</span><br><span class="line">        log.info(<span class="string">&quot;lazyLoad:&#123;&#125;&quot;</span>, helloWorldLazy.getField());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;Dispatcher&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDispatcher</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HelloWorldImpl</span> <span class="variable">helloWorld</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloWorldImpl</span>();</span><br><span class="line">        <span class="type">HelloWorldImpl</span> <span class="variable">helloWorldDispatcher</span> <span class="operator">=</span> helloWorld.dispatcher();</span><br><span class="line">        log.info(<span class="string">&quot;开始调用getField方法....&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;dispatcher:&#123;&#125;&quot;</span>, helloWorldDispatcher.getField());</span><br><span class="line">        log.info(<span class="string">&quot;dispatcher:&#123;&#125;&quot;</span>, helloWorldDispatcher.getField());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;ProxyRefDispatcher&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLazyLoader2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HelloWorldImpl</span> <span class="variable">helloWorld</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloWorldImpl</span>();</span><br><span class="line">        <span class="type">HelloWorldImpl</span> <span class="variable">helloWorldProxyRefDispatcher</span> <span class="operator">=</span> helloWorld.proxyRefDispatcher();</span><br><span class="line">        log.info(<span class="string">&quot;开始调用getField方法....&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;lazyLoad:&#123;&#125;&quot;</span>, helloWorldProxyRefDispatcher.getField());</span><br><span class="line">        log.info(<span class="string">&quot;lazyLoad:&#123;&#125;&quot;</span>, helloWorldProxyRefDispatcher.getField());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码<a href="git@github.com:/youtiaoguagua/cglib.git">获取</a>。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>cglib</tag>
      </tags>
  </entry>
</search>
